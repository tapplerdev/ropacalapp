import 'package:dio/dio.dart';
import 'package:latlong2/latlong.dart';
import 'package:flutter_polyline_points/flutter_polyline_points.dart';
import 'package:ropacalapp/core/utils/app_logger.dart';
import 'package:ropacalapp/models/route_step.dart';
import 'package:ropacalapp/models/bin.dart';

/// Mapbox Directions API v5 service for route calculation and navigation
///
/// Provides turn-by-turn routing with:
/// - Real-time traffic awareness
/// - Voice instructions (SSML format)
/// - Banner instructions for visual guidance
/// - Multiple routing profiles (driving-traffic, driving, walking, cycling)
/// - Support for up to 25 waypoints
///
/// API Documentation: https://docs.mapbox.com/api/navigation/directions/
class MapboxDirectionsService {
  final Dio _dio;
  final String accessToken;
  static const String _baseUrl = 'https://api.mapbox.com/directions/v5';

  MapboxDirectionsService({required this.accessToken, Dio? dio})
      : _dio = dio ?? Dio() {
    _dio.options.baseUrl = _baseUrl;
    _dio.options.connectTimeout = const Duration(seconds: 15);
    _dio.options.receiveTimeout = const Duration(seconds: 15);

    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          AppLogger.routing('üó∫Ô∏è  Mapbox Directions REQUEST:');
          AppLogger.routing('   Method: ${options.method}');
          AppLogger.routing('   URL: ${options.uri}');
          return handler.next(options);
        },
        onResponse: (response, handler) {
          AppLogger.routing('‚úÖ Mapbox Directions RESPONSE:');
          AppLogger.routing('   Status: ${response.statusCode}');
          AppLogger.routing(
            '   Body preview: ${response.data.toString().substring(0, response.data.toString().length > 200 ? 200 : response.data.toString().length)}...',
          );
          return handler.next(response);
        },
        onError: (error, handler) {
          AppLogger.routing('‚ùå Mapbox Directions ERROR:');
          AppLogger.routing('   Type: ${error.type}');
          AppLogger.routing('   Message: ${error.message}');

          if (error.response != null) {
            AppLogger.routing('   Status Code: ${error.response?.statusCode}');
            AppLogger.routing('   Response Body: ${error.response?.data}');
          }

          return handler.next(error);
        },
      ),
    );
  }

  /// Get route with turn-by-turn instructions and real-time traffic
  ///
  /// Uses Mapbox Directions API v5 to calculate routes with:
  /// - Real-time traffic data (driving-traffic profile)
  /// - Turn-by-turn instructions with voice guidance
  /// - Banner instructions for visual UI
  /// - Accurate travel time and distance
  ///
  /// [start] - Starting location (driver's current position)
  /// [destinations] - List of bins to visit in order
  /// [profile] - Routing profile: 'driving-traffic' (default), 'driving', 'walking', 'cycling'
  ///
  /// Returns route data including geometry, legs, steps, and voice/banner instructions
  Future<Map<String, dynamic>> getRoute({
    required LatLng start,
    required List<Bin> destinations,
    String profile = 'driving-traffic',
  }) async {
    try {
      AppLogger.routing('üìç Route start: ${start.latitude},${start.longitude}');
      AppLogger.routing(
        'üìç Route end: ${destinations.last.latitude},${destinations.last.longitude}',
      );
      AppLogger.routing('üöó Profile: $profile');

      // Build waypoints string: start;bin1;bin2;...;end
      final waypoints = <String>[];
      waypoints.add('${start.longitude},${start.latitude}'); // Mapbox uses lng,lat

      // Add all destination bins as waypoints
      for (final bin in destinations) {
        waypoints.add('${bin.longitude},${bin.latitude}');
      }

      final coordinatesString = waypoints.join(';');
      AppLogger.routing('üìç Total waypoints: ${waypoints.length}');

      // Build query parameters
      final queryParams = {
        'access_token': accessToken,
        'alternatives': 'false', // Only return best route
        'geometries': 'polyline', // Google polyline encoding (precision 5)
        'overview': 'full', // Full route geometry
        'steps': 'true', // Turn-by-turn instructions
        'banner_instructions': 'true', // Visual turn guidance
        'voice_instructions': 'true', // Voice announcements
        'voice_units': 'metric', // Use meters/kilometers
        'annotations': 'duration,distance,speed', // Additional metadata
        'language': 'en', // Instruction language
      };

      // API endpoint: /mapbox/{profile}/{coordinates}
      final response = await _dio.get(
        '/mapbox/$profile/$coordinatesString',
        queryParameters: queryParams,
      );

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;

        // Check for routes
        final routes = data['routes'] as List?;
        if (routes == null || routes.isEmpty) {
          throw Exception('No routes found in response');
        }

        return data;
      } else {
        throw Exception('Failed to get route: ${response.statusCode}');
      }
    } catch (e) {
      AppLogger.routing('‚ùå Error fetching Mapbox route: $e');
      rethrow;
    }
  }

  /// Parse Mapbox response into RouteStep objects for turn-by-turn navigation
  List<RouteStep> parseRouteSteps(Map<String, dynamic> mapboxResponse) {
    final steps = <RouteStep>[];

    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return steps;

      final route = routes.first as Map<String, dynamic>;
      final legs = route['legs'] as List;

      // Each leg is a section between waypoints
      for (var leg in legs) {
        final legSteps = leg['steps'] as List?;
        if (legSteps == null) continue;

        for (var step in legSteps) {
          final maneuver = step['maneuver'] as Map<String, dynamic>;

          final instruction = maneuver['instruction'] as String? ?? '';
          final distance = (step['distance'] as num?)?.toDouble() ?? 0.0;
          final duration = (step['duration'] as num?)?.toDouble() ?? 0.0;
          final maneuverType = maneuver['type'] as String? ?? 'continue';
          final modifier = maneuver['modifier'] as String?;
          final name = step['name'] as String? ?? '';

          // Extract location from maneuver
          final location = _extractLocation(maneuver);

          steps.add(
            RouteStep(
              instruction: instruction,
              distance: distance,
              duration: duration,
              maneuverType: maneuverType,
              location: location,
              modifier: modifier,
              name: name,
            ),
          );
        }
      }

      AppLogger.routing('üìç Parsed ${steps.length} Mapbox route steps');
      return steps;
    } catch (e) {
      AppLogger.routing('‚ùå Error parsing Mapbox route steps: $e');
      return steps;
    }
  }

  /// Extract voice instructions from Mapbox response
  ///
  /// Voice instructions include:
  /// - announcement: Full text instruction
  /// - ssmlAnnouncement: SSML formatted for TTS
  /// - distanceAlongGeometry: When to announce (meters from step start)
  ///
  /// Returns list of voice instruction objects
  List<Map<String, dynamic>> parseVoiceInstructions(
    Map<String, dynamic> mapboxResponse,
  ) {
    final voiceInstructions = <Map<String, dynamic>>[];

    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return voiceInstructions;

      final route = routes.first as Map<String, dynamic>;
      final legs = route['legs'] as List;

      for (var leg in legs) {
        final steps = leg['steps'] as List?;
        if (steps == null) continue;

        for (var step in steps) {
          final instructions = step['voiceInstructions'] as List?;
          if (instructions == null) continue;

          for (var instruction in instructions) {
            voiceInstructions.add({
              'announcement': instruction['announcement'] as String? ?? '',
              'ssmlAnnouncement': instruction['ssmlAnnouncement'] as String?,
              'distanceAlongGeometry':
                  (instruction['distanceAlongGeometry'] as num?)?.toDouble() ??
                      0.0,
            });
          }
        }
      }

      AppLogger.routing(
        'üîä Parsed ${voiceInstructions.length} voice instructions',
      );
      return voiceInstructions;
    } catch (e) {
      AppLogger.routing('‚ùå Error parsing voice instructions: $e');
      return voiceInstructions;
    }
  }

  /// Extract banner instructions from Mapbox response
  ///
  /// Banner instructions provide visual guidance for upcoming maneuvers
  /// Includes primary and secondary text, maneuver type, and distance
  List<Map<String, dynamic>> parseBannerInstructions(
    Map<String, dynamic> mapboxResponse,
  ) {
    final bannerInstructions = <Map<String, dynamic>>[];

    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return bannerInstructions;

      final route = routes.first as Map<String, dynamic>;
      final legs = route['legs'] as List;

      for (var leg in legs) {
        final steps = leg['steps'] as List?;
        if (steps == null) continue;

        for (var step in steps) {
          final instructions = step['bannerInstructions'] as List?;
          if (instructions == null) continue;

          for (var instruction in instructions) {
            final primary = instruction['primary'] as Map<String, dynamic>?;
            final secondary =
                instruction['secondary'] as Map<String, dynamic>?;

            bannerInstructions.add({
              'primaryText': primary?['text'] as String? ?? '',
              'secondaryText': secondary?['text'] as String?,
              'maneuverType': primary?['type'] as String?,
              'modifier': primary?['modifier'] as String?,
              'distanceAlongGeometry':
                  (instruction['distanceAlongGeometry'] as num?)?.toDouble() ??
                      0.0,
            });
          }
        }
      }

      AppLogger.routing(
        'üìã Parsed ${bannerInstructions.length} banner instructions',
      );
      return bannerInstructions;
    } catch (e) {
      AppLogger.routing('‚ùå Error parsing banner instructions: $e');
      return bannerInstructions;
    }
  }

  /// Calculate total distance from route response (meters)
  double getTotalDistance(Map<String, dynamic> mapboxResponse) {
    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return 0.0;

      final route = routes.first as Map<String, dynamic>;
      return (route['distance'] as num?)?.toDouble() ?? 0.0;
    } catch (e) {
      AppLogger.routing('‚ùå Error getting total distance: $e');
      return 0.0;
    }
  }

  /// Calculate total duration from route response (seconds)
  /// Includes real-time traffic for driving-traffic profile
  double getTotalDuration(Map<String, dynamic> mapboxResponse) {
    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return 0.0;

      final route = routes.first as Map<String, dynamic>;
      return (route['duration'] as num?)?.toDouble() ?? 0.0;
    } catch (e) {
      AppLogger.routing('‚ùå Error getting total duration: $e');
      return 0.0;
    }
  }

  /// Extract route polyline coordinates from Mapbox response
  ///
  /// Mapbox returns geometry in Google polyline format (precision 5)
  /// We decode it using flutter_polyline_points package
  List<LatLng> getRoutePolyline(Map<String, dynamic> mapboxResponse) {
    final polyline = <LatLng>[];

    try {
      AppLogger.routing('üîç Extracting polyline from Mapbox response...');
      final routes = mapboxResponse['routes'] as List;

      if (routes.isEmpty) {
        AppLogger.routing('‚ùå No routes in response');
        return polyline;
      }

      final route = routes.first as Map<String, dynamic>;
      final geometry = route['geometry'] as String?;

      if (geometry == null) {
        AppLogger.routing('‚ùå No geometry in route');
        return polyline;
      }

      // Decode Google polyline
      final points = _decodePolyline(geometry);
      polyline.addAll(points);

      AppLogger.routing('‚úÖ Extracted ${polyline.length} polyline points');
      if (polyline.isNotEmpty) {
        AppLogger.routing('   First point: ${polyline.first}');
        AppLogger.routing('   Last point: ${polyline.last}');
      }

      return polyline;
    } catch (e) {
      AppLogger.routing('‚ùå Error extracting route polyline: $e');
      return polyline;
    }
  }

  /// Get duration for each leg (waypoint to waypoint) in seconds
  ///
  /// Each leg represents travel between two consecutive waypoints
  /// Returns list where index 0 is origin->first bin, index 1 is first bin->second bin, etc.
  List<double> getLegDurations(Map<String, dynamic> mapboxResponse) {
    final legDurations = <double>[];

    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return legDurations;

      final route = routes.first as Map<String, dynamic>;
      final legs = route['legs'] as List;

      for (var leg in legs) {
        final duration = (leg['duration'] as num?)?.toDouble() ?? 0.0;
        legDurations.add(duration);
      }

      AppLogger.routing('üìä Extracted ${legDurations.length} leg durations');
      return legDurations;
    } catch (e) {
      AppLogger.routing('‚ùå Error getting leg durations: $e');
      return legDurations;
    }
  }

  /// Get distance for each leg (waypoint to waypoint) in meters
  List<double> getLegDistances(Map<String, dynamic> mapboxResponse) {
    final legDistances = <double>[];

    try {
      final routes = mapboxResponse['routes'] as List;
      if (routes.isEmpty) return legDistances;

      final route = routes.first as Map<String, dynamic>;
      final legs = route['legs'] as List;

      for (var leg in legs) {
        final distance = (leg['distance'] as num?)?.toDouble() ?? 0.0;
        legDistances.add(distance);
      }

      AppLogger.routing('üìä Extracted ${legDistances.length} leg distances');
      return legDistances;
    } catch (e) {
      AppLogger.routing('‚ùå Error getting leg distances: $e');
      return legDistances;
    }
  }

  /// Optimize waypoint order using Mapbox Optimization API
  ///
  /// The Optimization API finds the optimal order to visit waypoints
  /// based on travel time, taking traffic into account
  ///
  /// [start] - Starting location
  /// [destinations] - List of bins to optimize
  /// [profile] - Routing profile (default: 'driving-traffic')
  ///
  /// Returns optimized list of destination indices, or null if optimization fails
  /// Example: [2, 0, 1] means visit destinations[2], then destinations[0], then destinations[1]
  Future<List<int>?> getOptimizedWaypointSequence({
    required LatLng start,
    required List<Bin> destinations,
    String profile = 'driving-traffic',
  }) async {
    try {
      AppLogger.routing('üîÄ Requesting waypoint optimization...');
      AppLogger.routing('   Start: ${start.latitude},${start.longitude}');
      AppLogger.routing('   Destinations: ${destinations.length}');

      // Build waypoints: start;dest1;dest2;...;end
      // Note: Optimization API requires first and last to be fixed
      final waypoints = <String>[];
      waypoints.add('${start.longitude},${start.latitude}');

      for (final bin in destinations) {
        waypoints.add('${bin.longitude},${bin.latitude}');
      }

      final coordinatesString = waypoints.join(';');

      final queryParams = {
        'access_token': accessToken,
        'source': 'first', // Fix first waypoint (start)
        'destination': 'last', // Fix last waypoint (end)
        'roundtrip': 'false', // One-way trip
      };

      // Optimization API endpoint
      final response = await _dio.get(
        '/optimized-trips/v1/mapbox/$profile/$coordinatesString',
        queryParameters: queryParams,
      );

      if (response.statusCode == 200) {
        final data = response.data as Map<String, dynamic>;
        final trips = data['trips'] as List?;

        if (trips != null && trips.isNotEmpty) {
          final trip = trips.first as Map<String, dynamic>;
          final waypointIndices = trip['waypoint_indices'] as List?;

          if (waypointIndices != null) {
            // Convert to destination indices (skip start and end)
            final optimized = <int>[];
            for (var i = 1; i < waypointIndices.length - 1; i++) {
              final idx = waypointIndices[i] as int;
              if (idx > 0 && idx <= destinations.length) {
                optimized.add(idx - 1); // Map to destination index
              }
            }

            AppLogger.routing(
              '‚úÖ Optimized sequence (destination indices): $optimized',
            );
            return optimized;
          }
        }
      }

      AppLogger.routing('‚ö†Ô∏è  Optimization returned unexpected response');
      return null;
    } catch (e) {
      AppLogger.routing('‚ùå Error getting optimized sequence: $e');
      return null;
    }
  }

  /// Decode Google polyline format using flutter_polyline_points
  ///
  /// Mapbox uses standard Google polyline encoding (precision 5)
  /// which is different from HERE's flexible polyline format
  List<LatLng> _decodePolyline(String encoded) {
    try {
      final polylinePoints = PolylinePoints();
      final decoded = polylinePoints.decodePolyline(encoded);

      final coordinates = decoded
          .map((point) => LatLng(point.latitude, point.longitude))
          .toList();

      AppLogger.routing('‚úÖ Decoded ${coordinates.length} polyline points');
      return coordinates;
    } catch (e) {
      AppLogger.routing('‚ùå Error decoding polyline: $e');
      return [];
    }
  }

  /// Extract location from maneuver object
  LatLng _extractLocation(Map<String, dynamic> maneuver) {
    try {
      final location = maneuver['location'] as List?;
      if (location != null && location.length >= 2) {
        // Mapbox uses [lng, lat] order
        final lng = (location[0] as num).toDouble();
        final lat = (location[1] as num).toDouble();
        return LatLng(lat, lng);
      }
    } catch (e) {
      AppLogger.routing('‚ö†Ô∏è  Error extracting location: $e');
    }
    return const LatLng(0, 0);
  }
}
