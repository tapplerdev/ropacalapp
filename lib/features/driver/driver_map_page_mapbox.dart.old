import 'dart:async';
import 'dart:math';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:latlong2/latlong.dart' as latlong;
import 'package:flutter_compass/flutter_compass.dart';
import 'package:geolocator/geolocator.dart' as geolocator;
import 'package:ropacalapp/core/constants/bin_constants.dart';
import 'package:ropacalapp/core/theme/app_colors.dart';
import 'package:ropacalapp/core/utils/app_logger.dart';
import 'package:ropacalapp/providers/bins_provider.dart';
import 'package:ropacalapp/providers/location_provider.dart';
import 'package:ropacalapp/providers/shift_provider.dart';
import 'package:ropacalapp/providers/simulation_provider.dart';
import 'package:ropacalapp/providers/mapbox_route_provider.dart';
import 'package:ropacalapp/providers/navigation_provider.dart';
import 'package:ropacalapp/providers/offline_map_provider.dart';
import 'package:ropacalapp/models/shift_state.dart';
import 'package:ropacalapp/models/shift_overview.dart';
import 'package:ropacalapp/features/driver/widgets/active_shift_bottom_sheet.dart';
import 'package:ropacalapp/features/driver/widgets/pre_shift_overview_card.dart';
import 'package:ropacalapp/features/driver/widgets/turn_by_turn_navigation_card.dart';
import 'package:ropacalapp/features/driver/widgets/bin_details_bottom_sheet.dart';

/// Result of road snapping with position and route segment index
class _SnapResult {
  final Position position;
  final int segmentIndex;

  _SnapResult({required this.position, required this.segmentIndex});
}

/// Snaps a GPS position to the nearest point on a route polyline (road snapping)
/// This makes the navigation marker appear ON the road, like Google Maps
/// Returns both the snapped position and which segment it's on (for progressive polyline)
_SnapResult? _snapToRoute({
  required double gpsLat,
  required double gpsLng,
  required List<Position> routeCoordinates,
}) {
  if (routeCoordinates.isEmpty) return null;

  Position? closestPoint;
  int closestSegmentIndex = 0;
  double minDistance = double.infinity;

  // Check each segment of the route
  for (int i = 0; i < routeCoordinates.length - 1; i++) {
    final p1 = routeCoordinates[i];
    final p2 = routeCoordinates[i + 1];

    // Find closest point on this line segment to GPS position
    final snapped = _closestPointOnSegment(
      gpsLat: gpsLat,
      gpsLng: gpsLng,
      segmentStart: p1,
      segmentEnd: p2,
    );

    // Calculate distance from GPS to snapped point
    final distance = _haversineDistance(
      gpsLat,
      gpsLng,
      snapped.lat.toDouble(),
      snapped.lng.toDouble(),
    );

    if (distance < minDistance) {
      minDistance = distance;
      closestPoint = snapped;
      closestSegmentIndex = i;
    }
  }

  if (closestPoint == null) return null;

  return _SnapResult(position: closestPoint, segmentIndex: closestSegmentIndex);
}

/// Find the closest point on a line segment to a given point
Position _closestPointOnSegment({
  required double gpsLat,
  required double gpsLng,
  required Position segmentStart,
  required Position segmentEnd,
}) {
  final x1 = segmentStart.lng.toDouble();
  final y1 = segmentStart.lat.toDouble();
  final x2 = segmentEnd.lng.toDouble();
  final y2 = segmentEnd.lat.toDouble();
  final px = gpsLng;
  final py = gpsLat;

  final dx = x2 - x1;
  final dy = y2 - y1;

  if (dx == 0 && dy == 0) {
    // Segment is a point
    return segmentStart;
  }

  // Project point onto line, t = 0..1 is on segment
  final t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);

  if (t < 0) {
    // Closest to start
    return segmentStart;
  } else if (t > 1) {
    // Closest to end
    return segmentEnd;
  } else {
    // Closest to middle of segment
    return Position(x1 + t * dx, y1 + t * dy);
  }
}

/// Calculate distance between two lat/lng points in meters using Haversine formula
double _haversineDistance(double lat1, double lng1, double lat2, double lng2) {
  const earthRadius = 6371000.0; // meters
  final dLat = (lat2 - lat1) * (3.14159 / 180.0);
  final dLng = (lng2 - lng1) * (3.14159 / 180.0);

  final a = (dLat / 2).abs() * (dLat / 2).abs() +
      lat1.abs() * lat2.abs() * (dLng / 2).abs() * (dLng / 2).abs();
  final c = 2 * (a < 1 ? a : 1 - a).abs();

  return earthRadius * c;
}

/// Mapbox-powered driver map page with Uber-style navigation
class DriverMapPageMapbox extends HookConsumerWidget {
  const DriverMapPageMapbox({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final binsState = ref.watch(binsListProvider);
    final locationState = ref.watch(currentLocationProvider);
    final shiftState = ref.watch(shiftNotifierProvider);
    final simulationState = ref.watch(simulationNotifierProvider);
    final mapboxRouteData = ref.watch(mapboxRouteMetadataProvider);
    final navigationState = ref.watch(navigationNotifierProvider);
    final offlineMapService = ref.watch(offlineMapServiceProvider);

    final mapboxMap = useState<MapboxMap?>(null);
    final compassHeading = useState<double?>(null);
    final isAutoFollowEnabled = useState<bool>(true);
    final isNavigationView = useState<bool>(true); // true = first-person, false = flat
    final viewportState = useState<ViewportState?>(null);
    final pointAnnotationManager = useState<PointAnnotationManager?>(null);
    final polylineAnnotationManager = useState<PolylineAnnotationManager?>(
      null,
    );
    final binAnnotationMap = useState<Map<String, dynamic>>({});
    final simulationPuck = useState<PointAnnotation?>(null); // Custom puck annotation during simulation
    final currentRouteSegmentIndex = useState<int>(0); // Track current position on route for progressive polyline
    final isUpdatingPuck = useState<bool>(false); // Prevent concurrent puck updates
    final navigationArrowBytes = useState<Uint8List?>(null); // Navigation arrow image bytes

    // Debug camera controls for finding ideal navigation view
    final debugZoom = useState<double>(BinConstants.navigationZoom);
    final debugPitch = useState<double>(BinConstants.navigationTilt);
    final debugBearing = useState<double>(0.0);
    final debugPaddingTop = useState<double>(BinConstants.navigationPaddingTop);
    final debugPaddingBottom = useState<double>(BinConstants.navigationPaddingBottom);
    final debugPaddingLeft = useState<double>(BinConstants.navigationPaddingLeft);
    final debugPaddingRight = useState<double>(BinConstants.navigationPaddingRight);
    final showDebugControls = useState<bool>(false); // Set to true to adjust camera

    // Initial camera position - San Jose or current location
    final initialCenter = useMemoized(
      () => locationState.value != null
          ? Point(
              coordinates: Position(
                locationState.value!.longitude,
                locationState.value!.latitude,
              ),
            )
          : Point(coordinates: Position(-121.8863, 37.3382)), // San Jose
      [locationState.value],
    );

    // Track last camera update time for throttling
    final lastCameraUpdateTime = useRef<DateTime?>(null);
    final currentBearing = useRef<double>(0.0);

    // HYBRID BEARING SYSTEM: GPS bearing when moving, compass when stationary
    // Automatically updates camera based on location and compass changes
    useEffect(() {
      // Don't run camera updates if not in active navigation
      if (mapboxMap.value == null ||
          shiftState.status != ShiftStatus.active ||
          !isNavigationView.value ||
          !isAutoFollowEnabled.value ||
          locationState.value == null ||
          showDebugControls.value) {
        return null;
      }

      final map = mapboxMap.value!;
      final location = locationState.value!;

      // DETERMINE BEARING SOURCE: GPS (moving) vs Compass (stationary)
      double? bearing;
      String bearingSource = '';

      // Get current speed (m/s)
      final speed = location.speed ?? 0.0;
      final isMoving = speed > 1.0; // Moving if speed > 1 m/s (~3.6 km/h)

      if (isMoving && location.heading != null && location.heading! >= 0) {
        // USE GPS BEARING when moving (most reliable, no magnetic interference)
        bearing = location.heading!;
        bearingSource = 'GPS';
      } else if (compassHeading.value != null) {
        // USE COMPASS when stationary (GPS bearing unreliable when not moving)
        bearing = compassHeading.value!;
        bearingSource = 'Compass';
      }

      // Only update if we have a valid bearing
      if (bearing == null) return null;

      // THROTTLE CAMERA UPDATES: Max 10 FPS (every 100ms) to prevent performance issues
      final now = DateTime.now();
      if (lastCameraUpdateTime.value != null) {
        final timeSinceLastUpdate = now.difference(lastCameraUpdateTime.value!);
        if (timeSinceLastUpdate.inMilliseconds < 100) {
          return null; // Skip this update
        }
      }

      // Update tracking
      lastCameraUpdateTime.value = now;
      currentBearing.value = bearing;

      // FULL MANUAL CAMERA CONTROL: Update bearing, center, zoom, pitch, AND padding
      map.easeTo(
        CameraOptions(
          center: Point(
            coordinates: Position(location.longitude, location.latitude),
          ),
          bearing: bearing,
          zoom: BinConstants.navigationZoom,
          pitch: BinConstants.navigationTilt,
          padding: MbxEdgeInsets(
            top: BinConstants.navigationPaddingTop,
            bottom: BinConstants.navigationPaddingBottom,
            left: BinConstants.navigationPaddingLeft,
            right: BinConstants.navigationPaddingRight,
          ),
        ),
        MapAnimationOptions(duration: 200), // Smooth 200ms animation
      );

      AppLogger.map('üéØ Camera update: bearing=${bearing.toStringAsFixed(1)}¬∞ [$bearingSource], speed=${speed.toStringAsFixed(1)} m/s');

      return null;
    }, [
      mapboxMap.value,
      shiftState.status,
      isNavigationView.value,
      isAutoFollowEnabled.value,
      showDebugControls.value,
      locationState.value?.latitude,
      locationState.value?.longitude,
      locationState.value?.heading,
      locationState.value?.speed,
      compassHeading.value,
    ]);

    // Listen to compass for stationary bearing updates
    useEffect(() {
      StreamSubscription<CompassEvent>? compassSubscription;
      compassSubscription = FlutterCompass.events?.listen((event) {
        if (event.heading != null) {
          compassHeading.value = event.heading;
        }
      });
      return () => compassSubscription?.cancel();
    }, []);

    // Download offline map tiles when route is loaded
    useEffect(
      () {
        if (mapboxRouteData != null && shiftState.assignedRouteId != null) {
          AppLogger.map('üì• Route loaded - downloading offline map tiles');

          // Calculate bounds from route polyline
          final polyline = mapboxRouteData.polyline;
          if (polyline.isEmpty) {
            AppLogger.map('‚ö†Ô∏è  Route polyline is empty, skipping offline download');
            return null;
          }

          // Find min/max lat/lng from polyline points
          double minLat = polyline.first.latitude;
          double maxLat = polyline.first.latitude;
          double minLng = polyline.first.longitude;
          double maxLng = polyline.first.longitude;

          for (final point in polyline) {
            if (point.latitude < minLat) minLat = point.latitude;
            if (point.latitude > maxLat) maxLat = point.latitude;
            if (point.longitude < minLng) minLng = point.longitude;
            if (point.longitude > maxLng) maxLng = point.longitude;
          }

          // Add padding to bounds (10% on each side)
          final latPadding = (maxLat - minLat) * 0.1;
          final lngPadding = (maxLng - minLng) * 0.1;

          final bounds = CoordinateBounds(
            southwest: Point(
              coordinates: Position(
                minLng - lngPadding,
                minLat - latPadding,
              ),
            ),
            northeast: Point(
              coordinates: Position(
                maxLng + lngPadding,
                maxLat + latPadding,
              ),
            ),
            infiniteBounds: false,
          );

          AppLogger.map(
            'üì¶ Calculated bounds:\n'
            '   SW: ${bounds.southwest.coordinates.lat}, ${bounds.southwest.coordinates.lng}\n'
            '   NE: ${bounds.northeast.coordinates.lat}, ${bounds.northeast.coordinates.lng}',
          );

          // Trigger offline download
          offlineMapService.downloadRouteRegion(
            bounds: bounds,
            routeId: shiftState.assignedRouteId!,
            onProgress: (progress) {
              AppLogger.map('üì• Offline download: ${(progress * 100).toStringAsFixed(1)}%');
            },
          );
        }

        return null;
      },
      [mapboxRouteData, shiftState.assignedRouteId],
    );

    // Start navigation when shift becomes active
    useEffect(
      () {
        if (shiftState.status == ShiftStatus.active &&
            navigationState == null &&
            locationState.value != null &&
            mapboxRouteData != null) {
          final currentLocation = latlong.LatLng(
            locationState.value!.latitude,
            locationState.value!.longitude,
          );

          AppLogger.map('üöÄ Starting navigation - shift is active');
          AppLogger.map('   üìä binsState status: ${binsState.runtimeType}');
          AppLogger.map('   üìç currentLocation: ${currentLocation.latitude}, ${currentLocation.longitude}');
          AppLogger.map('   üì¶ routeBins count: ${shiftState.routeBins.length}');
          AppLogger.map('   üó∫Ô∏è  mapboxRouteData: ${mapboxRouteData != null ? "AVAILABLE (${mapboxRouteData!.steps.length} steps)" : "NULL"}');

          // Convert RouteBin to Bin for navigation
          // Delay modification to avoid build-time provider updates
          Future(() {
            AppLogger.map('üîç Inside Future() - checking binsState...');

            binsState.when(
              data: (allBins) {
                AppLogger.map('‚úÖ binsState has data - ${allBins.length} bins available');

                final destinationBins = shiftState.routeBins
                    .map(
                      (routeBin) =>
                          allBins.firstWhere((bin) => bin.id == routeBin.binId),
                    )
                    .toList();

                AppLogger.map('‚úÖ Converted ${destinationBins.length} destination bins');
                AppLogger.map('üöÄ Calling startNavigationWithMapboxData()...');

                ref
                    .read(navigationNotifierProvider.notifier)
                    .startNavigationWithMapboxData(
                      startLocation: currentLocation,
                      destinationBins: destinationBins,
                    );

                AppLogger.map('‚úÖ startNavigationWithMapboxData() called successfully');
              },
              loading: () {
                AppLogger.map('‚è≥ binsState is LOADING - cannot start navigation yet');
              },
              error: (error, stack) {
                AppLogger.map('‚ùå binsState has ERROR - cannot start navigation: $error');
              },
            );
          });
        }

        // Stop navigation when shift ends
        if (shiftState.status != ShiftStatus.active &&
            navigationState != null) {
          AppLogger.map('üõë Stopping navigation - shift not active');
          // Delay modification to avoid build-time provider updates
          Future(() {
            ref.read(navigationNotifierProvider.notifier).stopNavigation();
          });
        }

        return null;
      },
      [shiftState.status, navigationState, locationState.value, mapboxRouteData, binsState],
    );

    // Initialize viewport state when navigation starts
    useEffect(
      () {
        // DISABLED: Using full manual camera control instead of FollowPuckViewportState
        // Manual control in compass listener handles: center, bearing, zoom, pitch, padding
        // FollowPuckViewportState doesn't support padding (GitHub #816/#825)

        // if (shiftState.status == ShiftStatus.active &&
        //     mapboxMap.value != null &&
        //     isAutoFollowEnabled.value &&
        //     viewportState.value == null) {
        //   viewportState.value = FollowPuckViewportState(
        //     zoom: BinConstants.navigationZoom,
        //     bearing: FollowPuckViewportStateBearingConstant(0),
        //     pitch: BinConstants.navigationTilt,
        //   );
        //   AppLogger.map('üéØ Viewport state initialized (manual bearing control)');
        // }

        // Reset viewport when shift ends
        if (shiftState.status != ShiftStatus.active) {
          viewportState.value = null;
          isAutoFollowEnabled.value = true;
        }

        return null;
      },
      [
        shiftState.status,
        mapboxMap.value,
        isAutoFollowEnabled.value,
      ],
    );

    // REMOVED: Manual camera updates - Now relying on Mapbox's native FollowPuckViewportState
    // Research showed FollowPuckViewportStateBearingHeading() works correctly on Android
    // The viewport state automatically handles camera bearing and position tracking
    // No need for manual easeTo() calls - simpler and officially supported!

    // DEBUG CAMERA CONTROLS: Apply debug camera settings when debug mode is active
    useEffect(
      () {
        if (!showDebugControls.value) return null;
        if (mapboxMap.value == null) return null;
        if (locationState.value == null) return null;

        final map = mapboxMap.value!;
        final center = Point(
          coordinates: Position(
            locationState.value!.longitude,
            locationState.value!.latitude,
          ),
        );

        // Apply debug camera settings with padding
        map.easeTo(
          CameraOptions(
            center: center,
            bearing: debugBearing.value,
            zoom: debugZoom.value,
            pitch: debugPitch.value,
            padding: MbxEdgeInsets(
              top: debugPaddingTop.value,
              bottom: debugPaddingBottom.value,
              left: debugPaddingLeft.value,
              right: debugPaddingRight.value,
            ),
          ),
          MapAnimationOptions(duration: 300),
        );

        AppLogger.map(
          'üé® DEBUG: Camera updated - '
          'zoom: ${debugZoom.value.toStringAsFixed(1)}, '
          'pitch: ${debugPitch.value.toStringAsFixed(1)}¬∞, '
          'bearing: ${debugBearing.value.toStringAsFixed(1)}¬∞, '
          'padding: [T:${debugPaddingTop.value.toInt()}, B:${debugPaddingBottom.value.toInt()}, '
          'L:${debugPaddingLeft.value.toInt()}, R:${debugPaddingRight.value.toInt()}]',
        );

        return null;
      },
      [
        showDebugControls.value,
        debugZoom.value,
        debugPitch.value,
        debugBearing.value,
        debugPaddingTop.value,
        debugPaddingBottom.value,
        debugPaddingLeft.value,
        debugPaddingRight.value,
        locationState.value?.latitude,
        locationState.value?.longitude,
      ],
    );

    // ROAD SNAPPING PUCK: Custom annotation that snaps to route (Google Maps style)
    // Native puck is invisible but enabled for compass tracking
    useEffect(
      () {
        if (mapboxMap.value == null || pointAnnotationManager.value == null) {
          return null;
        }

        final map = mapboxMap.value!;
        final manager = pointAnnotationManager.value!;

        if (simulationState.isSimulating && locationState.value != null) {
          // SIMULATION MODE: Custom annotation with road snapping
          // Native puck stays enabled (invisible) for compass tracking

          // Get simulated position from currentLocationProvider
          // (simulation updates this provider with simulated coordinates)
          final simLat = locationState.value!.latitude;
          final simLng = locationState.value!.longitude;
          final simBearing = simulationState.smoothedBearing ?? simulationState.bearing;

          // Prevent concurrent updates that create multiple arrows
          if (isUpdatingPuck.value) {
            return null;
          }

          // Update custom puck annotation
          isUpdatingPuck.value = true;
          Future(() async {
            try {
              // Delete old puck if exists (ignore errors if not yet added)
              if (simulationPuck.value != null) {
                try {
                  await manager.delete(simulationPuck.value!);
                  simulationPuck.value = null;
                } catch (e) {
                  // Ignore "not added" errors during rapid updates
                  if (!e.toString().contains('not been added')) {
                    AppLogger.map('‚ö†Ô∏è  Delete error: $e');
                  }
                }
              }

              // ROAD SNAPPING: Snap GPS position to route for Google Maps-style display
              double displayLng = simLng;
              double displayLat = simLat;

              if (mapboxRouteData != null && mapboxRouteData.polyline.isNotEmpty) {
                // Convert route polyline to Position format
                final routeCoords = mapboxRouteData.polyline
                    .map((p) => Position(p.longitude, p.latitude))
                    .toList();

                // Snap current position to nearest point on route
                final snapResult = _snapToRoute(
                  gpsLat: simLat,
                  gpsLng: simLng,
                  routeCoordinates: routeCoords,
                );

                if (snapResult != null) {
                  displayLng = snapResult.position.lng.toDouble();
                  displayLat = snapResult.position.lat.toDouble();
                  currentRouteSegmentIndex.value = snapResult.segmentIndex;
                  AppLogger.map('üìç Snapped to route segment ${snapResult.segmentIndex}: ${(simLat - displayLat).abs() * 111000}m offset');
                }
              }

              // Create custom puck with navigation arrow (points "up" - camera handles rotation)
              final puckAnnotation = PointAnnotationOptions(
                geometry: Point(coordinates: Position(displayLng, displayLat)),
                iconImage: 'navigation-arrow', // Use pre-loaded navigation arrow
                iconSize: 0.8,
                iconRotate: 0.0, // Always point "up" - camera bearing rotates map!
                iconAnchor: IconAnchor.CENTER,
              );

              final created = await manager.create(puckAnnotation);
              simulationPuck.value = created;
            } catch (e) {
              AppLogger.map('‚ö†Ô∏è  Error updating simulation puck: $e');
            } finally {
              isUpdatingPuck.value = false;
            }
          });
        } else if (navigationState != null && locationState.value != null) {
          // REAL GPS MODE: Custom annotation with road snapping
          // Native puck stays enabled (invisible) for compass tracking

          // Get real GPS position and bearing
          final gpsLat = locationState.value!.latitude;
          final gpsLng = locationState.value!.longitude;
          final gpsBearing = navigationState.currentBearing ?? 0.0;

          // Prevent concurrent updates
          if (isUpdatingPuck.value) {
            return null;
          }

          // Update custom puck annotation with navigation arrow
          isUpdatingPuck.value = true;
          Future(() async {
            try {
              // Delete old puck if exists
              if (simulationPuck.value != null) {
                try {
                  await manager.delete(simulationPuck.value!);
                  simulationPuck.value = null;
                } catch (e) {
                  if (!e.toString().contains('not been added')) {
                    AppLogger.map('‚ö†Ô∏è  Delete error: $e');
                  }
                }
              }

              // ROAD SNAPPING: Snap GPS position to route for Google Maps-style display
              double displayLng = gpsLng;
              double displayLat = gpsLat;

              if (mapboxRouteData != null && mapboxRouteData.polyline.isNotEmpty) {
                // Convert route polyline to Position format
                final routeCoords = mapboxRouteData.polyline
                    .map((p) => Position(p.longitude, p.latitude))
                    .toList();

                // Snap current position to nearest point on route
                final snapResult = _snapToRoute(
                  gpsLat: gpsLat,
                  gpsLng: gpsLng,
                  routeCoordinates: routeCoords,
                );

                if (snapResult != null) {
                  displayLng = snapResult.position.lng.toDouble();
                  displayLat = snapResult.position.lat.toDouble();
                  currentRouteSegmentIndex.value = snapResult.segmentIndex;
                  AppLogger.map('üìç GPS snapped to route segment ${snapResult.segmentIndex}: ${(gpsLat - displayLat).abs() * 111000}m offset');
                }
              }

              // Create custom puck with navigation arrow (points "up" - camera handles rotation)
              final puckAnnotation = PointAnnotationOptions(
                geometry: Point(coordinates: Position(displayLng, displayLat)),
                iconImage: 'navigation-arrow', // Use pre-loaded navigation arrow
                iconSize: 0.8,
                iconRotate: 0.0, // Always point "up" - camera bearing rotates map!
                iconAnchor: IconAnchor.CENTER,
              );

              final created = await manager.create(puckAnnotation);
              simulationPuck.value = created;
            } catch (e) {
              AppLogger.map('‚ö†Ô∏è  Error updating GPS puck: $e');
            } finally {
              isUpdatingPuck.value = false;
            }
          });
        } else {
          // No navigation - remove custom puck and show default
          if (simulationPuck.value != null) {
            Future(() async {
              try {
                await manager.delete(simulationPuck.value!);
                simulationPuck.value = null;
                isUpdatingPuck.value = false;
              } catch (e) {
                AppLogger.map('‚ö†Ô∏è  Error removing puck: $e');
              }
            });
          }

          // Show default location puck
          map.location.updateSettings(
            LocationComponentSettings(
              enabled: true,
              pulsingEnabled: true,
              pulsingColor: AppColors.primaryBlue.value,
            ),
          );
        }

        return null;
      },
      [
        simulationState.isSimulating,
        locationState.value?.latitude,
        locationState.value?.longitude,
        simulationState.bearing,
        simulationState.smoothedBearing,
        navigationState?.currentBearing,
        mapboxMap.value,
        pointAnnotationManager.value,
      ],
    );


    // Update markers when bins or location changes
    useEffect(() {
      if (pointAnnotationManager.value == null) return null;

      binsState.whenData((bins) async {
        try {
          // Clear existing annotations
          await pointAnnotationManager.value!.deleteAll();

          final options = <PointAnnotationOptions>[];
          final newBinMap = <String, dynamic>{};

          // Add bin markers with unique numbered icons
          for (final bin in bins) {
            if (bin.longitude == null || bin.latitude == null) continue;
            final point = Point(
              coordinates: Position(bin.longitude!, bin.latitude!),
            );
            final option = PointAnnotationOptions(
              geometry: point,
              iconImage: 'marker-bin-${bin.id}',
              iconSize: BinConstants.binMarkerIconScale,
              iconAnchor: IconAnchor.CENTER,
            );
            options.add(option);
          }

          // Note: User location is now handled by Mapbox's built-in location component
          // No need to add custom marker

          final annotations = await pointAnnotationManager.value!.createMulti(options);

          // Map annotation IDs to bins for tap handling
          for (int i = 0; i < annotations.length; i++) {
            final annotation = annotations[i];
            final annotationId = annotation?.id;
            if (annotationId != null && annotation != null) {
              newBinMap[annotationId] = bins[i];
            }
          }
          binAnnotationMap.value = newBinMap;

          AppLogger.map('‚úÖ Created ${options.length} Mapbox markers');
        } catch (e) {
          AppLogger.map('‚ùå Error updating markers: $e');
        }
      });

      return null;
    }, [binsState, pointAnnotationManager.value]);

    // Handle marker tap to show bin details
    useEffect(() {
      final manager = pointAnnotationManager.value;
      if (manager == null) return null;

      manager.addOnPointAnnotationClickListener(_BinMarkerClickListener(
        binMap: binAnnotationMap.value,
        onBinTapped: (bin) {
          AppLogger.map('üìç Marker tapped: Bin #${bin.binNumber}');
          showModalBottomSheet(
            context: context,
            isScrollControlled: true,
            backgroundColor: Colors.transparent,
            builder: (context) => BinDetailsBottomSheet(bin: bin),
          );
        },
      ));

      return null;
    }, [pointAnnotationManager.value, binAnnotationMap.value]);

    // Update Mapbox location puck position (only when NOT navigating)
    useEffect(
      () {
        if (mapboxMap.value == null || locationState.value == null) return null;
        // Skip during simulation OR real navigation - custom arrow is used instead
        if (simulationState.isSimulating || navigationState != null) return null;

        final currentSpeed = locationState.value!.speed ?? 0.0;
        const speedThreshold = 1.0;
        final isMoving = currentSpeed >= speedThreshold;
        final gpsBearing =
            simulationState.smoothedBearing ?? simulationState.bearing;
        final bearing = isMoving
            ? gpsBearing
            : (compassHeading.value ?? gpsBearing);

        // Update location component bearing
        mapboxMap.value!.location.updateSettings(
          LocationComponentSettings(
            enabled: true,
            pulsingEnabled: !isMoving, // Pulse when stationary
            pulsingColor: AppColors.primaryBlue.value,
            showAccuracyRing: false,
            locationPuck: LocationPuck(
              locationPuck2D: DefaultLocationPuck2D(
                bearingImage: null,
                shadowImage: null,
                topImage: null,
              ),
            ),
          ),
        );

        return null;
      },
      [
        locationState.value,
        mapboxMap.value,
        compassHeading.value,
        simulationState.bearing,
        navigationState, // Re-run when navigation starts/stops
      ],
    );

    // Update route polyline (progressive - only show remaining route ahead)
    useEffect(() {
      if (polylineAnnotationManager.value == null || mapboxRouteData == null)
        return null;

      try {
        polylineAnnotationManager.value!.deleteAll().then((_) async {
          if (mapboxRouteData.polyline.isEmpty) return;

          // Get all route coordinates
          final allCoordinates = mapboxRouteData.polyline
              .map((point) => Position(point.longitude, point.latitude))
              .toList();

          // Only show route from current segment forward (Google Maps style)
          final startIndex = currentRouteSegmentIndex.value.clamp(0, allCoordinates.length - 1);
          final remainingCoordinates = allCoordinates.sublist(startIndex);

          if (remainingCoordinates.isEmpty) return;

          final lineString = LineString(coordinates: remainingCoordinates);
          final option = PolylineAnnotationOptions(
            geometry: lineString,
            lineColor: AppColors.primaryBlue.value,
            lineWidth: 5.0,
          );

          await polylineAnnotationManager.value!.create(option);
          AppLogger.map(
            '‚úÖ Updated progressive polyline: ${remainingCoordinates.length}/${allCoordinates.length} points remaining (from segment $startIndex)',
          );
        });
      } catch (e) {
        AppLogger.map('‚ùå Error updating polyline: $e');
      }

      return null;
    }, [mapboxRouteData, polylineAnnotationManager.value, currentRouteSegmentIndex.value]);

    return Scaffold(
      body: binsState.when(
        data: (bins) {
          return Stack(
            children: [
              // Mapbox Map
              MapWidget(
                key: const ValueKey('mapbox_map'),
                viewport: viewportState.value,
                cameraOptions: CameraOptions(
                  center: initialCenter,
                  zoom: BinConstants.navigationZoom, // Start with navigation zoom
                  pitch: BinConstants.navigationTilt, // Start with street-level view
                  bearing: 0.0,
                ),
                styleUri: MapboxStyles.MAPBOX_STREETS,
                mapOptions: MapOptions(
                  pixelRatio: MediaQuery.of(context).devicePixelRatio,
                ),
                textureView: true,
                onMapCreated: (map) async {
                  mapboxMap.value = map;
                  AppLogger.map('üó∫Ô∏è  Mapbox Map created');
                  AppLogger.map('‚è≥ Waiting for style to load...');
                },
                onScrollListener: (screenCoordinate) {
                  // User is manually panning the map - disable auto-follow
                  if (isAutoFollowEnabled.value) {
                    isAutoFollowEnabled.value = false;
                    AppLogger.map('üëÜ User panned map - auto-follow disabled');
                  }
                },
                  onStyleLoadedListener: (styleLoadedEventData) async {
                    AppLogger.map('üé® Style loaded successfully!');
                    AppLogger.map('   Style URI: ${MapboxStyles.MAPBOX_STREETS}');

                    final map = mapboxMap.value;
                    if (map == null) {
                      AppLogger.map('‚ùå Map is null in onStyleLoaded!');
                      return;
                    }

                    try {
                      // Load marker images and get navigation arrow bytes
                      final navArrowBytes = await _loadMarkerImages(map, bins);
                      navigationArrowBytes.value = navArrowBytes;

                      // Enable location component with INVISIBLE puck for compass tracking
                      // The invisible puck allows FollowPuckViewportState to track compass heading
                      // We'll use a custom annotation for the visible arrow with road snapping
                      await map.location.updateSettings(
                        LocationComponentSettings(
                          enabled: true, // MUST be enabled for FollowPuckViewportState to work!
                          pulsingEnabled: false,
                          puckBearing: PuckBearing.HEADING, // Rotate with compass (for viewport tracking)
                          puckBearingEnabled: true,
                          showAccuracyRing: false,
                          locationPuck: LocationPuck(
                            locationPuck2D: DefaultLocationPuck2D(
                              topImage: navArrowBytes,
                              bearingImage: null,
                              shadowImage: null,
                              opacity: 0.01, // ‚úÖ INVISIBLE! Custom annotation will be visible
                            ),
                          ),
                        ),
                      );
                      AppLogger.map('‚úÖ LocationPuck enabled (invisible) for compass tracking');

                      // Create annotation managers
                      pointAnnotationManager.value = await map.annotations
                          .createPointAnnotationManager();
                      polylineAnnotationManager.value = await map.annotations
                          .createPolylineAnnotationManager();
                      AppLogger.map('‚úÖ Annotation managers created');

                      // Enable all gesture settings for user interaction
                      await map.gestures.updateSettings(GesturesSettings(
                        scrollEnabled: true, // Allow panning/scrolling
                        rotateEnabled: true, // Allow rotation
                        pitchEnabled: true, // Allow tilt adjustment
                        pinchToZoomEnabled: true, // Allow zoom
                        doubleTapToZoomInEnabled: true,
                        doubleTouchToZoomOutEnabled: true,
                        quickZoomEnabled: true,
                      ));
                      AppLogger.map('‚úÖ Gesture settings enabled (pan, rotate, pitch, zoom)');
                    } catch (e) {
                      AppLogger.map('‚ùå Error in onStyleLoaded: $e');
                    }
                  },
                  onMapLoadErrorListener: (mapLoadingErrorEventData) {
                    AppLogger.map('‚ùå MAP LOAD ERROR: ${mapLoadingErrorEventData.message}');
                    AppLogger.map('   Type: ${mapLoadingErrorEventData.type}');
                  },
                  onRenderFrameStartedListener: (_) {
                    // Map is actively rendering
                  },
                ),

              // Turn-by-turn navigation card (when navigating)
              if (shiftState.status == ShiftStatus.active &&
                  mapboxRouteData != null &&
                  mapboxRouteData.steps.isNotEmpty)
                Positioned(
                  top: MediaQuery.of(context).padding.top + 16,
                  left: 0,
                  right: 0,
                  child: TurnByTurnNavigationCard(
                    // Use navigationState if available, otherwise fallback to mapboxRouteData
                    currentStep:
                        navigationState?.currentStep ??
                        mapboxRouteData.steps.first,
                    distanceToNextManeuver:
                        navigationState?.distanceToNextManeuver ?? 150,
                    estimatedTimeRemaining:
                        navigationState?.estimatedArrival != null
                        ? navigationState!.estimatedArrival!.difference(
                            DateTime.now(),
                          )
                        : Duration(
                            seconds: mapboxRouteData.totalDuration.toInt(),
                          ),
                    totalDistanceRemaining:
                        navigationState?.remainingDistance ??
                        mapboxRouteData.totalDistance,
                  ),
                ),

              // Compass/View toggle button
              Positioned(
                top: MediaQuery.of(context).padding.top + 130,
                right: 16,
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.white,
                    shape: BoxShape.circle,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: () {
                        // Toggle view mode
                        isNavigationView.value = !isNavigationView.value;

                        AppLogger.map(
                          'üß≠ View toggle: ${isNavigationView.value ? "Navigation (first-person)" : "Map (flat)"}',
                        );

                        // DISABLED: Using full manual camera control instead
                        // Manual camera updates handled by compass listener
                        AppLogger.map(isNavigationView.value
                          ? 'üéØ View: Navigation mode (manual camera)'
                          : 'üó∫Ô∏è  View: Flat mode (manual camera)');
                      },
                      customBorder: const CircleBorder(),
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Icon(
                          Icons.explore,
                          color: isNavigationView.value
                              ? AppColors.primaryBlue
                              : Colors.grey.shade800,
                          size: 24,
                        ),
                      ),
                    ),
                  ),
                ),
              ),

              // Recenter button
              Positioned(
                top: MediaQuery.of(context).padding.top + 200,
                right: 16,
                child: Container(
                  decoration: BoxDecoration(
                    color: isAutoFollowEnabled.value
                        ? AppColors.primaryBlue
                        : Colors.white,
                    shape: BoxShape.circle,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: Material(
                    color: Colors.transparent,
                    child: InkWell(
                      onTap: () {
                        AppLogger.map(
                          'üìç Recenter tapped - enabling auto-follow',
                        );
                        isAutoFollowEnabled.value = true;
                        isNavigationView.value = true; // Return to first-person view

                        // DISABLED: Using full manual camera control instead
                        // Manual camera updates handled by compass listener
                        AppLogger.map('üéØ Recenter: Manual camera control active');
                      },
                      customBorder: const CircleBorder(),
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Icon(
                          Icons.my_location,
                          color: isAutoFollowEnabled.value
                              ? Colors.white
                              : Colors.grey.shade800,
                          size: 24,
                        ),
                      ),
                    ),
                  ),
                ),
              ),

              // Pre-shift overview (when ready but not started)
              if (shiftState.status == ShiftStatus.ready)
                Positioned(
                  bottom: 0,
                  left: 0,
                  right: 0,
                  child: PreShiftOverviewCard(
                    shiftOverview: ShiftOverview(
                      shiftId: shiftState.assignedRouteId ?? '',
                      startTime: DateTime.now(),
                      estimatedEndTime: DateTime.now().add(
                        Duration(
                          seconds: (mapboxRouteData?.totalDuration ?? 0).toInt(),
                        ),
                      ),
                      totalBins: shiftState.routeBins.length,
                      totalDistanceKm:
                          (mapboxRouteData?.totalDistance ?? 0) / 1000,
                      routeBins: shiftState.routeBins,
                      routeName: shiftState.assignedRouteId ?? 'Route',
                    ),
                    onStartShift: () {
                      ref.read(shiftNotifierProvider.notifier).startShift();
                    },
                  ),
                ),

              // Active shift bottom sheet
              if (shiftState.status == ShiftStatus.active)
                Positioned(
                  bottom: 0,
                  left: 0,
                  right: 0,
                  child: ActiveShiftBottomSheet(
                    routeBins: shiftState.routeBins,
                    completedBins: shiftState.completedBins,
                    totalBins: shiftState.totalBins,
                    onNavigateToNextBin: () {
                      // Find next incomplete bin
                      final nextBin = shiftState.routeBins.firstWhere(
                        (bin) => bin.isCompleted == 0,
                        orElse: () => shiftState.routeBins.first,
                      );

                      AppLogger.map(
                        'üß≠ Navigating to next bin: ${nextBin.binId}',
                      );
                      // Navigation is handled automatically by shift state
                    },
                    preComputedPolyline: mapboxRouteData?.polyline,
                  ),
                ),

              // Debug Camera Controls Overlay
              if (showDebugControls.value)
                Positioned(
                  top: 50,
                  left: 10,
                  right: 10,
                  child: Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.8),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            const Text(
                              'üì∏ Camera Debug Controls',
                              style: TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.close, color: Colors.white),
                              onPressed: () => showDebugControls.value = false,
                              padding: EdgeInsets.zero,
                              constraints: const BoxConstraints(),
                            ),
                          ],
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Bearing: ${debugBearing.value.toStringAsFixed(1)}¬∞',
                          style: const TextStyle(color: Colors.white),
                        ),
                        Row(
                          children: [
                            IconButton(
                              icon: const Icon(Icons.remove, color: Colors.white),
                              onPressed: () {
                                debugBearing.value = (debugBearing.value - 15) % 360;
                              },
                            ),
                            Expanded(
                              child: Slider(
                                value: debugBearing.value,
                                min: 0,
                                max: 360,
                                onChanged: (value) => debugBearing.value = value,
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.add, color: Colors.white),
                              onPressed: () {
                                debugBearing.value = (debugBearing.value + 15) % 360;
                              },
                            ),
                          ],
                        ),
                        Text(
                          'Zoom: ${debugZoom.value.toStringAsFixed(1)}',
                          style: const TextStyle(color: Colors.white),
                        ),
                        Row(
                          children: [
                            IconButton(
                              icon: const Icon(Icons.remove, color: Colors.white),
                              onPressed: () {
                                debugZoom.value = (debugZoom.value - 0.5).clamp(10.0, 22.0);
                              },
                            ),
                            Expanded(
                              child: Slider(
                                value: debugZoom.value,
                                min: 10.0,
                                max: 22.0,
                                onChanged: (value) => debugZoom.value = value,
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.add, color: Colors.white),
                              onPressed: () {
                                debugZoom.value = (debugZoom.value + 0.5).clamp(10.0, 22.0);
                              },
                            ),
                          ],
                        ),
                        Text(
                          'Pitch/Tilt: ${debugPitch.value.toStringAsFixed(1)}¬∞',
                          style: const TextStyle(color: Colors.white),
                        ),
                        Row(
                          children: [
                            IconButton(
                              icon: const Icon(Icons.remove, color: Colors.white),
                              onPressed: () {
                                debugPitch.value = (debugPitch.value - 5).clamp(0.0, 85.0);
                              },
                            ),
                            Expanded(
                              child: Slider(
                                value: debugPitch.value,
                                min: 0.0,
                                max: 85.0,
                                onChanged: (value) => debugPitch.value = value,
                              ),
                            ),
                            IconButton(
                              icon: const Icon(Icons.add, color: Colors.white),
                              onPressed: () {
                                debugPitch.value = (debugPitch.value + 5).clamp(0.0, 85.0);
                              },
                            ),
                          ],
                        ),
                        const Divider(color: Colors.white54, height: 24),
                        const Text(
                          'Camera Padding (pixels)',
                          style: TextStyle(color: Colors.white70, fontSize: 12),
                        ),
                        const SizedBox(height: 8),
                        Row(
                          children: [
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Top: ${debugPaddingTop.value.toInt()}',
                                    style: const TextStyle(color: Colors.white, fontSize: 11),
                                  ),
                                  Slider(
                                    value: debugPaddingTop.value,
                                    min: 0,
                                    max: 500,
                                    divisions: 100,
                                    onChanged: (value) => debugPaddingTop.value = value,
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Bottom: ${debugPaddingBottom.value.toInt()}',
                                    style: const TextStyle(color: Colors.white, fontSize: 11),
                                  ),
                                  Slider(
                                    value: debugPaddingBottom.value,
                                    min: 0,
                                    max: 500,
                                    divisions: 100,
                                    onChanged: (value) => debugPaddingBottom.value = value,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                        Row(
                          children: [
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Left: ${debugPaddingLeft.value.toInt()}',
                                    style: const TextStyle(color: Colors.white, fontSize: 11),
                                  ),
                                  Slider(
                                    value: debugPaddingLeft.value,
                                    min: 0,
                                    max: 500,
                                    divisions: 100,
                                    onChanged: (value) => debugPaddingLeft.value = value,
                                  ),
                                ],
                              ),
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    'Right: ${debugPaddingRight.value.toInt()}',
                                    style: const TextStyle(color: Colors.white, fontSize: 11),
                                  ),
                                  Slider(
                                    value: debugPaddingRight.value,
                                    min: 0,
                                    max: 500,
                                    divisions: 100,
                                    onChanged: (value) => debugPaddingRight.value = value,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 8),
                        ElevatedButton(
                          onPressed: () {
                            AppLogger.map(
                              '\nüéØ COPY THESE VALUES:\n'
                              '   navigationZoom: ${debugZoom.value.toStringAsFixed(1)}\n'
                              '   navigationTilt: ${debugPitch.value.toStringAsFixed(1)}\n'
                              '   bearing (if fixed): ${debugBearing.value.toStringAsFixed(1)}¬∞\n'
                              '   padding: EdgeInsets.only(\n'
                              '      top: ${debugPaddingTop.value.toInt()},\n'
                              '      bottom: ${debugPaddingBottom.value.toInt()},\n'
                              '      left: ${debugPaddingLeft.value.toInt()},\n'
                              '      right: ${debugPaddingRight.value.toInt()},\n'
                              '   )\n',
                            );
                          },
                          child: const Text('Log Current Values'),
                        ),
                      ],
                    ),
                  ),
                ),
            ],
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(child: Text('Error: $error')),
      ),
    );
  }

  /// Load marker images into Mapbox map style
  /// Returns the navigation arrow bytes for use in LocationPuck2D
  static Future<Uint8List> _loadMarkerImages(
    MapboxMap map,
    List<dynamic> bins,
  ) async {
    try {
      // Load blue dot and navigation arrow
      final blueDot = await _createCircleMarker(Colors.blue, 50);
      final navigationArrow = await _createNavigationArrow(60);

      await map.style.addStyleImage(
        'blue-dot',
        1.0,
        MbxImage(width: 50, height: 50, data: blueDot),
        false,
        [],
        [],
        null,
      );
      await map.style.addStyleImage(
        'navigation-arrow',
        1.0,
        MbxImage(width: 60, height: 60, data: navigationArrow),
        false,
        [],
        [],
        null,
      );

      // Generate unique numbered marker for each bin
      for (final bin in bins) {
        final binNumber = bin.binNumber as int? ?? 0;
        final fillPercentage = bin.fillPercentage as int? ?? 0;
        final binId = bin.id as String;

        final markerImage = await _createNumberedBinMarker(
          binNumber: binNumber,
          fillPercentage: fillPercentage,
        );

        await map.style.addStyleImage(
          'marker-bin-$binId',
          1.0,
          MbxImage(width: 100, height: 100, data: markerImage),
          false,
          [],
          [],
          null,
        );
      }

      AppLogger.map(
        '‚úÖ Marker images loaded: ${bins.length} bin markers + navigation assets',
      );

      return navigationArrow; // Return bytes for LocationPuck2D
    } catch (e) {
      AppLogger.map('‚ùå Error loading marker images: $e');
      rethrow; // Re-throw to handle error in caller
    }
  }

  /// Create numbered bin marker with progress arc
  static Future<Uint8List> _createNumberedBinMarker({
    required int binNumber,
    required int fillPercentage,
  }) async {
    const size = 100.0;
    const radius = size / 2;
    const strokeWidth = 8.0;

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final color = _getBinFillColor(fillPercentage);

    // Draw white background circle
    final backgroundPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill
      ..isAntiAlias = true;
    canvas.drawCircle(const Offset(radius, radius), radius, backgroundPaint);

    // Draw progress arc
    if (fillPercentage > 0) {
      final progressPaint = Paint()
        ..color = color
        ..style = PaintingStyle.stroke
        ..strokeWidth = strokeWidth
        ..strokeCap = StrokeCap.round
        ..isAntiAlias = true;

      const startAngle = -90 * 3.14159 / 180;
      final sweepAngle = 2 * 3.14159 * (fillPercentage / 100);

      canvas.drawArc(
        Rect.fromCircle(
          center: const Offset(radius, radius),
          radius: radius - strokeWidth / 2,
        ),
        startAngle,
        sweepAngle,
        false,
        progressPaint,
      );
    }

    // Draw border
    final borderPaint = Paint()
      ..color = Colors.black.withOpacity(0.2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0
      ..isAntiAlias = true;
    canvas.drawCircle(const Offset(radius, radius), radius, borderPaint);

    // Draw bin number
    final textPainter = TextPainter(
      text: TextSpan(
        text: binNumber.toString(),
        style: const TextStyle(
          color: Color(0xFF1A1A1A),
          fontWeight: FontWeight.bold,
          fontSize: 48.0,
          height: 1.0,
        ),
      ),
      textDirection: TextDirection.ltr,
      textAlign: TextAlign.center,
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(radius - textPainter.width / 2, radius - textPainter.height / 2),
    );

    // Convert to image
    final picture = recorder.endRecording();
    final image = await picture.toImage(size.toInt(), size.toInt());
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    return byteData!.buffer.asUint8List();
  }

  /// Get fill color based on bin fill percentage
  static Color _getBinFillColor(int fillPercentage) {
    if (fillPercentage > 74) {
      return AppColors.alertRed;
    } else if (fillPercentage > 49) {
      return AppColors.warningOrange;
    } else {
      return AppColors.successGreen;
    }
  }

  /// Create a simple circle marker as Uint8List
  static Future<Uint8List> _createCircleMarker(Color color, double size) async {
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    // Draw white border
    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;
    canvas.drawCircle(Offset(size / 2, size / 2), size / 2, borderPaint);

    // Draw colored circle
    canvas.drawCircle(Offset(size / 2, size / 2), (size / 2) - 3, paint);

    final picture = recorder.endRecording();
    final img = await picture.toImage(size.toInt(), size.toInt());
    final byteData = await img.toByteData(format: ui.ImageByteFormat.png);
    return byteData!.buffer.asUint8List();
  }

  /// Create Google Maps-style navigation puck (blue circle with
  /// directional cone)
  /// Pointing up (will be rotated by bearing)
  static Future<Uint8List> _createNavigationArrow(double size) async {
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final center = size / 2;

    // Google Maps blue color (#4285F4)
    final googleBlue = const Color(0xFF4285F4);

    // Shadow paint
    final shadowPaint = Paint()
      ..color = Colors.black.withOpacity(0.25)
      ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 3);

    // Main blue circle radius
    final circleRadius = size * 0.25;

    // Directional cone paint
    final conePaint = Paint()
      ..color = googleBlue
      ..style = PaintingStyle.fill;

    // White border for cone
    final coneBorderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    // Circle paint
    final circlePaint = Paint()
      ..color = googleBlue
      ..style = PaintingStyle.fill;

    // White border for circle
    final circleBorderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.5;

    // 1. Draw directional cone (pointing up)
    final conePath = Path();
    final coneWidth = size * 0.4;
    final coneLength = size * 0.5;
    final coneTipY = center - coneLength;

    // Start at center (base of cone)
    conePath.moveTo(center, center);
    // Left edge of cone
    conePath.lineTo(center - coneWidth / 2, center - coneLength * 0.3);
    // Tip of cone
    conePath.lineTo(center, coneTipY);
    // Right edge of cone
    conePath.lineTo(center + coneWidth / 2, center - coneLength * 0.3);
    conePath.close();

    // Draw cone shadow
    canvas.save();
    canvas.translate(0.5, 1.5);
    canvas.drawPath(conePath, shadowPaint);
    canvas.restore();

    // Draw cone with border
    canvas.drawPath(conePath, conePaint);
    canvas.drawPath(conePath, coneBorderPaint);

    // 2. Draw main blue circle in center
    // Circle shadow
    canvas.save();
    canvas.translate(0.5, 1.5);
    canvas.drawCircle(Offset(center, center), circleRadius, shadowPaint);
    canvas.restore();

    // Circle with white border
    canvas.drawCircle(Offset(center, center), circleRadius, circlePaint);
    canvas.drawCircle(
      Offset(center, center),
      circleRadius,
      circleBorderPaint,
    );

    final picture = recorder.endRecording();
    final img = await picture.toImage(size.toInt(), size.toInt());
    final byteData = await img.toByteData(format: ui.ImageByteFormat.png);
    return byteData!.buffer.asUint8List();
  }
}

/// Custom click listener for bin markers
class _BinMarkerClickListener extends OnPointAnnotationClickListener {
  final Map<String, dynamic> binMap;
  final Function(dynamic bin) onBinTapped;

  _BinMarkerClickListener({
    required this.binMap,
    required this.onBinTapped,
  });

  @override
  void onPointAnnotationClick(PointAnnotation annotation) {
    final bin = binMap[annotation.id];
    if (bin != null) {
      onBinTapped(bin);
    }
  }
}
