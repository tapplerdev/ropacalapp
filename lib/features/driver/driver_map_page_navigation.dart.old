import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:flutter_mapbox_navigation/flutter_mapbox_navigation.dart';
import 'package:ropacalapp/core/theme/app_colors.dart';
import 'package:ropacalapp/core/utils/app_logger.dart';
import 'package:ropacalapp/providers/shift_provider.dart';
import 'package:ropacalapp/providers/location_provider.dart';
import 'package:ropacalapp/models/shift_state.dart';
import 'package:ropacalapp/models/route_bin.dart';

/// Driver map page using Mapbox Navigation SDK
/// Provides turn-by-turn navigation with voice guidance for bin collection routes
class DriverMapPageNavigation extends HookConsumerWidget {
  const DriverMapPageNavigation({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final shiftState = ref.watch(shiftNotifierProvider);
    final locationState = ref.watch(currentLocationProvider);

    // Navigation state
    final isNavigating = useState<bool>(false);
    final currentBinIndex = useState<int>(0);
    final navigationInstance = useMemoized(() => MapBoxNavigation.instance);

    // Event listener cleanup
    final eventListenerFuture = useRef<Future<dynamic>?>(null);

    // Get current bin being navigated to
    RouteBin? getCurrentBin() {
      if (shiftState.routeBins.isEmpty) return null;

      // Find first uncompleted bin
      final uncompletedBins = shiftState.routeBins
          .where((bin) => bin.isCompleted == 0)
          .toList();

      if (uncompletedBins.isEmpty) return null;

      return uncompletedBins.first;
    }

    // Convert route bins to waypoints
    List<WayPoint> getWaypoints() {
      final bins = shiftState.routeBins;
      if (bins.isEmpty) return [];

      final waypoints = <WayPoint>[];

      // Add current location as starting point if available
      if (locationState.value != null) {
        waypoints.add(
          WayPoint(
            name: "Current Location",
            latitude: locationState.value!.latitude,
            longitude: locationState.value!.longitude,
          ),
        );
      }

      // Add all uncompleted bins in sequence order
      final uncompletedBins = bins
          .where((bin) => bin.isCompleted == 0)
          .toList()
        ..sort((a, b) => a.sequenceOrder.compareTo(b.sequenceOrder));

      for (final bin in uncompletedBins) {
        waypoints.add(
          WayPoint(
            name: bin.currentStreet,
            latitude: bin.latitude,
            longitude: bin.longitude,
          ),
        );
      }

      AppLogger.map(
        'üó∫Ô∏è  Generated ${waypoints.length} waypoints (${uncompletedBins.length} bins)',
      );

      return waypoints;
    }

    // Start navigation
    Future<void> startNavigation() async {
      try {
        final waypoints = getWaypoints();
        if (waypoints.length < 2) {
          AppLogger.map('‚ö†Ô∏è  Need at least 2 waypoints to start navigation');
          return;
        }

        AppLogger.map('üöÄ Starting navigation with ${waypoints.length} waypoints');

        final options = MapBoxOptions(
          mode: MapBoxNavigationMode.drivingWithTraffic,
          simulateRoute: true, // Set to false for real navigation
          language: "en",
          voiceInstructionsEnabled: true,
          bannerInstructionsEnabled: true,
          isOptimized: false, // Keep backend's sequence order
          allowsUTurnAtWayPoints: true,
          zoom: 19.0,
          tilt: 68.4,
          bearing: 0.0,
          animateBuildRoute: true,
          longPressDestinationEnabled: false,
        );

        await navigationInstance.startNavigation(
          wayPoints: waypoints,
          options: options,
        );

        isNavigating.value = true;
        AppLogger.map('‚úÖ Navigation started successfully');
      } catch (e) {
        AppLogger.map('‚ùå Error starting navigation: $e', level: AppLogger.error);
      }
    }

    // Stop navigation
    Future<void> stopNavigation() async {
      try {
        await navigationInstance.finishNavigation();
        isNavigating.value = false;
        AppLogger.map('üõë Navigation stopped');
      } catch (e) {
        AppLogger.map('‚ùå Error stopping navigation: $e', level: AppLogger.error);
      }
    }

    // Handle bin arrival
    Future<void> handleBinArrival() async {
      final currentBin = getCurrentBin();
      if (currentBin == null) {
        AppLogger.map('‚ö†Ô∏è  No current bin to complete');
        return;
      }

      try {
        AppLogger.map('üìç Arrived at bin: ${currentBin.currentStreet}');

        // Mark bin as completed
        await ref.read(shiftNotifierProvider.notifier).completeBin(currentBin.binId);

        currentBinIndex.value++;

        AppLogger.map(
          '‚úÖ Bin completed: ${shiftState.completedBins}/${shiftState.totalBins}',
        );

        // Check if route is complete
        if (ref.read(shiftNotifierProvider.notifier).isRouteComplete()) {
          AppLogger.map('üéâ All bins completed!');
          await stopNavigation();
        }
      } catch (e) {
        AppLogger.map('‚ùå Error completing bin: $e', level: AppLogger.error);
      }
    }

    // Listen to navigation events
    useEffect(() {
      final future = navigationInstance.registerRouteEventListener((event) {
        AppLogger.map('üì° Navigation event: ${event.eventType}');

        switch (event.eventType) {
          case MapBoxEvent.on_arrival:
            // Arrived at a waypoint
            handleBinArrival();
            break;

          case MapBoxEvent.navigation_running:
            AppLogger.map('üèÉ Navigation is running');
            break;

          case MapBoxEvent.navigation_finished:
            AppLogger.map('üèÅ Navigation finished');
            isNavigating.value = false;
            break;

          case MapBoxEvent.navigation_cancelled:
            AppLogger.map('‚ùå Navigation cancelled');
            isNavigating.value = false;
            break;

          case MapBoxEvent.route_building:
            AppLogger.map('üî® Building route...');
            break;

          case MapBoxEvent.route_built:
            AppLogger.map('‚úÖ Route built successfully');
            break;

          case MapBoxEvent.route_build_failed:
            AppLogger.map('‚ùå Route build failed', level: AppLogger.error);
            break;

          case MapBoxEvent.progress_change:
            // Progress update - could be used for UI updates
            final data = event.data as Map<String, dynamic>?;
            if (data != null) {
              final distanceRemaining = data['distanceRemaining'] as num?;
              final durationRemaining = data['durationRemaining'] as num?;

              if (distanceRemaining != null && durationRemaining != null) {
                AppLogger.map(
                  'üìä Progress: ${(distanceRemaining / 1000).toStringAsFixed(1)} km, '
                  '${(durationRemaining / 60).toStringAsFixed(0)} min remaining',
                );
              }
            }
            break;

          default:
            AppLogger.map('üì° Other event: ${event.eventType}');
        }
      });

      eventListenerFuture.value = future;
      return null;
    }, []);

    // Auto-start navigation when shift becomes active
    useEffect(() {
      if (shiftState.status == ShiftStatus.active &&
          !isNavigating.value &&
          shiftState.routeBins.isNotEmpty) {
        // Small delay to ensure location is ready
        Future.delayed(const Duration(milliseconds: 500), () {
          startNavigation();
        });
      }
      return null;
    }, [shiftState.status, shiftState.routeBins.length]);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Navigation'),
        backgroundColor: AppColors.primaryBlue,
        foregroundColor: Colors.white,
        actions: [
          // Shift status indicator
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            margin: const EdgeInsets.only(right: 8),
            decoration: BoxDecoration(
              color: _getStatusColor(shiftState.status),
              borderRadius: BorderRadius.circular(16),
            ),
            child: Text(
              _getStatusText(shiftState.status),
              style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
                fontSize: 12,
              ),
            ),
          ),
        ],
      ),
      body: Stack(
        children: [
          // Mapbox Navigation View
          MapBoxNavigationView(
            options: MapBoxOptions(
              mode: MapBoxNavigationMode.drivingWithTraffic,
              simulateRoute: true, // Set to false for real navigation
              language: "en",
              voiceInstructionsEnabled: true,
              bannerInstructionsEnabled: true,
              zoom: 19.0,
              tilt: 68.4,
              bearing: 0.0,
            ),
            onRouteEvent: (event) => AppLogger.map('Route event: ${event.eventType}'),
            onCreated: (controller) {
              AppLogger.map('üó∫Ô∏è  Navigation view created');
            },
          ),

          // Bottom info card
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(20),
                  topRight: Radius.circular(20),
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 10,
                    offset: const Offset(0, -2),
                  ),
                ],
              ),
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // Progress bar
                  Row(
                    children: [
                      Text(
                        '${shiftState.completedBins}/${shiftState.totalBins}',
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                        ),
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(8),
                          child: LinearProgressIndicator(
                            value: ref.read(shiftNotifierProvider.notifier)
                                .getCompletionPercentage(),
                            backgroundColor: Colors.grey[200],
                            color: AppColors.primaryBlue,
                            minHeight: 8,
                          ),
                        ),
                      ),
                    ],
                  ),

                  const SizedBox(height: 16),

                  // Current bin info
                  if (getCurrentBin() != null) ...[
                    Row(
                      children: [
                        Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: AppColors.primaryBlue.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Icon(
                            Icons.location_on,
                            color: AppColors.primaryBlue,
                            size: 24,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              const Text(
                                'Next Stop',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: Colors.grey,
                                ),
                              ),
                              Text(
                                getCurrentBin()!.currentStreet,
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              Text(
                                '${getCurrentBin()!.city}, ${getCurrentBin()!.zip}',
                                style: const TextStyle(
                                  fontSize: 12,
                                  color: Colors.grey,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Control buttons
                  Row(
                    children: [
                      if (shiftState.status == ShiftStatus.active) ...[
                        Expanded(
                          child: OutlinedButton.icon(
                            onPressed: () async {
                              await stopNavigation();
                              await ref.read(shiftNotifierProvider.notifier).pauseShift();
                            },
                            icon: const Icon(Icons.pause),
                            label: const Text('Pause'),
                            style: OutlinedButton.styleFrom(
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: ElevatedButton.icon(
                            onPressed: () async {
                              await stopNavigation();
                              await ref.read(shiftNotifierProvider.notifier).endShift();
                            },
                            icon: const Icon(Icons.stop),
                            label: const Text('End Shift'),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.red,
                              foregroundColor: Colors.white,
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                          ),
                        ),
                      ] else if (shiftState.status == ShiftStatus.paused) ...[
                        Expanded(
                          child: ElevatedButton.icon(
                            onPressed: () async {
                              await ref.read(shiftNotifierProvider.notifier).resumeShift();
                              await startNavigation();
                            },
                            icon: const Icon(Icons.play_arrow),
                            label: const Text('Resume'),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: AppColors.primaryBlue,
                              foregroundColor: Colors.white,
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Color _getStatusColor(ShiftStatus status) {
    switch (status) {
      case ShiftStatus.active:
        return Colors.green;
      case ShiftStatus.paused:
        return Colors.orange;
      case ShiftStatus.ready:
        return Colors.blue;
      case ShiftStatus.inactive:
        return Colors.grey;
    }
  }

  String _getStatusText(ShiftStatus status) {
    switch (status) {
      case ShiftStatus.active:
        return 'ACTIVE';
      case ShiftStatus.paused:
        return 'PAUSED';
      case ShiftStatus.ready:
        return 'READY';
      case ShiftStatus.inactive:
        return 'INACTIVE';
    }
  }
}
