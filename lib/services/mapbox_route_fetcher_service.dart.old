import 'package:riverpod/riverpod.dart';
import 'package:latlong2/latlong.dart' as latlong;
import 'package:ropacalapp/core/services/mapbox_directions_service.dart';
import 'package:ropacalapp/core/utils/app_logger.dart';
import 'package:ropacalapp/models/bin.dart';
import 'package:ropacalapp/models/route_bin.dart';
import 'package:ropacalapp/providers/mapbox_route_provider.dart';
import 'package:ropacalapp/core/enums/bin_status.dart';

/// Service for fetching and storing Mapbox Directions API routes
/// Centralizes route fetching logic used across the app
class MapboxRouteFetcherService {
  final MapboxDirectionsService mapboxService;
  final Ref ref;

  MapboxRouteFetcherService({required this.mapboxService, required this.ref});

  /// Fetch Mapbox Directions API route and store in mapboxRouteMetadataProvider
  ///
  /// [currentLocation] - Driver's current GPS location
  /// [routeBins] - List of bins in the route (from shift data)
  /// [optimize] - Whether to use waypoint optimization (default: true)
  ///
  /// Returns true if successful, false if failed
  Future<bool> fetchAndStoreRoute({
    required latlong.LatLng currentLocation,
    required List<RouteBin> routeBins,
    bool optimize = true,
  }) async {
    try {
      AppLogger.routing('ðŸš— MapboxRouteFetcherService: Starting route fetch...');
      AppLogger.routing(
        '   Current location: ${currentLocation.latitude},${currentLocation.longitude}',
      );
      AppLogger.routing('   Route bins: ${routeBins.length}');
      AppLogger.routing('   Optimize: $optimize');

      // Step 1: Convert RouteBins to Bins
      final binList = _convertToBins(routeBins);

      // Step 2: Get optimized waypoint sequence (if enabled)
      List<Bin> orderedBins;
      if (optimize) {
        final optimizedIndices =
            await mapboxService.getOptimizedWaypointSequence(
          start: currentLocation,
          destinations: binList,
        );

        if (optimizedIndices != null && optimizedIndices.isNotEmpty) {
          orderedBins = optimizedIndices.map((idx) => binList[idx]).toList();
          AppLogger.routing(
            'ðŸŽ¯ Using optimized order: ${orderedBins.map((b) => b.binNumber ?? 0).toList()}',
          );

          // Log differences from backend order
          for (int i = 0; i < binList.length; i++) {
            final backendBin = binList[i].binNumber ?? 0;
            final mapboxBin = orderedBins[i].binNumber ?? 0;
            if (backendBin != mapboxBin) {
              AppLogger.routing(
                '   Position $i: Backend=#$backendBin â†’ Mapbox=#$mapboxBin',
              );
            }
          }
        } else {
          // Optimization failed - use backend order
          AppLogger.routing(
            'âš ï¸  Optimization unavailable, using backend order',
          );
          orderedBins = binList;
        }
      } else {
        // Optimization disabled - use backend order
        orderedBins = binList;
      }

      // Step 3: Get route with traffic-aware durations and voice/banner instructions
      final mapboxResponse = await mapboxService.getRoute(
        start: currentLocation,
        destinations: orderedBins,
        profile: 'driving-traffic', // Traffic-aware routing
      );

      // Step 4: Extract route data
      final legDurations = mapboxService.getLegDurations(mapboxResponse);
      final legDistances = mapboxService.getLegDistances(mapboxResponse);
      final totalDuration = mapboxService.getTotalDuration(mapboxResponse);
      final totalDistance = mapboxService.getTotalDistance(mapboxResponse);
      final polyline = mapboxService.getRoutePolyline(mapboxResponse);
      final steps = mapboxService.parseRouteSteps(mapboxResponse);

      // Step 5: Extract voice and banner instructions (Mapbox-specific)
      final voiceInstructions =
          mapboxService.parseVoiceInstructions(mapboxResponse);
      final bannerInstructions =
          mapboxService.parseBannerInstructions(mapboxResponse);

      AppLogger.routing('ðŸ“ Route metrics:');
      AppLogger.routing('   Bins/waypoints: ${orderedBins.length}');
      AppLogger.routing('   Sections received: ${legDurations.length}');
      AppLogger.routing(
        '   Total duration: ${(totalDuration / 60).toStringAsFixed(1)} min',
      );
      AppLogger.routing(
        '   Total distance: ${(totalDistance / 1000).toStringAsFixed(2)} km',
      );
      AppLogger.routing('   Polyline points: ${polyline.length}');
      AppLogger.routing('   Turn instructions: ${steps.length}');
      AppLogger.routing('   Voice instructions: ${voiceInstructions.length}');
      AppLogger.routing('   Banner instructions: ${bannerInstructions.length}');

      // Verify section count matches waypoint count
      if (legDurations.length != orderedBins.length) {
        AppLogger.routing('âš ï¸  WARNING: Section count mismatch!');
        AppLogger.routing(
          '   Expected ${orderedBins.length} sections, got ${legDurations.length}',
        );
      }

      // Step 6: Store route metadata
      ref.read(mapboxRouteMetadataProvider.notifier).setRouteData(
            legDurations: legDurations,
            legDistances: legDistances,
            totalDuration: totalDuration,
            totalDistance: totalDistance,
            polyline: polyline,
            steps: steps,
            voiceInstructions: voiceInstructions,
            bannerInstructions: bannerInstructions,
          );

      AppLogger.routing('âœ… Mapbox Directions route fetched & stored successfully');
      return true;
    } catch (e, stackTrace) {
      AppLogger.routing('âŒ Error fetching Mapbox route: $e');
      AppLogger.routing(
        '   Stack trace: ${stackTrace.toString().split('\n').take(3).join('\n')}',
      );
      return false;
    }
  }

  /// Convert RouteBins to Bins for Mapbox API
  List<Bin> _convertToBins(List<RouteBin> routeBins) {
    return routeBins.map((routeBin) {
      return Bin(
        id: routeBin.binId,
        binNumber: routeBin.binNumber,
        currentStreet: routeBin.currentStreet,
        city: routeBin.city,
        zip: routeBin.zip,
        latitude: routeBin.latitude,
        longitude: routeBin.longitude,
        fillPercentage: routeBin.fillPercentage,
        status: BinStatus.active,
        lastMoved: null,
        lastChecked: null,
        checked: false,
        moveRequested: false,
      );
    }).toList();
  }
}
